// Package grpcinstrument helps instrumenting gRPC servers.
//
// This package defines the Instrumentator interface which applications must
// implement to integrate with whatever instrumentation infrastructure is at
// their disposale. This includes, but is not limited to, logging and metrics.
//
// It also includes the `protoc-gen-grpcinstrument` Protocol Buffer compiler
// plugin for generating code that wraps and instruments gRPC server
// implementations.
package grpcinstrument

import (
	"time"

	"go.pedge.io/proto/time"
)

// Instrumentator is the interface that servers must implement in order to
// integrate with the code generated by the protoc plugin plugin.
type Instrumentator interface {
	Init() error
	Instrument(*Call)
}

// Logger is the interface for logging RPC calls.
type Logger interface {
	Init() error
	Log(*Call)
}

// Measurer is the interface for measuring (error rate, latency, ...) RPC calls.
type Measurer interface {
	Init() error
	Measure(*Call)
}

// LoggerMeasurer implements the most common use case of the Instrumentator
// interface, logging RPC calls and collecting metrics about them.
func NewLoggerMeasurer(logger Logger, measurer Measurer) Instrumentator {
	return newLoggerMeasurer(logger, measurer)
}

// Instrument is the method used by the code generated by the protoc plugin
// included in this package.
func Instrument(
	instrumentator Instrumentator,
	serviceName string,
	methodName string,
	inputType string,
	outputType string,
	err error,
	start time.Time,
) {
	call := &Call{
		Service:  serviceName,
		Method:   methodName,
		Input:    &Input{Type: inputType},
		Output:   &Output{Type: outputType},
		Duration: prototime.DurationToProto(time.Since(start)),
	}
	if err != nil {
		call.Error = &Error{Message: err.Error()}
	}
	instrumentator.Instrument(call)
}

// IsError returns true if the server responded to the request with an error,
// false otherwise.
func (c *Call) IsError() bool {
	return c.Error != nil
}
